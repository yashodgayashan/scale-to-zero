% Libraries Used in Scale-to-Zero Research Project
% LaTeX longtable format for academic papers

\documentclass{article}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}

\begin{document}

\begin{longtable}{|p{3cm}|p{1.5cm}|p{5cm}|p{3cm}|}
\caption{Libraries and Technologies Used in Scale-to-Zero TestApp Project} \label{tab:libraries} \\

\hline
\textbf{Library/Technology} & \textbf{Version} & \textbf{Purpose/Function} & \textbf{Category} \\
\hline
\endfirsthead

\multicolumn{4}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline
\textbf{Library/Technology} & \textbf{Version} & \textbf{Purpose/Function} & \textbf{Category} \\
\hline
\endhead

\hline \multicolumn{4}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline
\endlastfoot

% eBPF Framework
\multirow{5}{*}{eBPF Framework} & & & \\
aya & 0.13.1 & Pure Rust eBPF library and program loader & eBPF Core \\
aya-ebpf & 0.1.1 & eBPF program development framework & eBPF Development \\
aya-log & 0.2.1 & Userspace logging for eBPF programs & eBPF Logging \\
aya-log-ebpf & 0.1.1 & eBPF side logging macros & eBPF Logging \\
aya-build & 0.1.2 & Build system integration for eBPF & eBPF Build Tools \\
\hline

% Kubernetes
\multirow{2}{*}{Kubernetes} & & & \\
kube & 0.87.2 & Rust Kubernetes API client library & K8s Client \\
k8s-openapi & 0.20.0 & Kubernetes OpenAPI bindings for Rust & K8s API Bindings \\
\hline

% Networking
\multirow{2}{*}{Networking} & & & \\
network-interface & 1.1.1 & Network interface enumeration and management & Network Interface \\
network-types & 0.0.8 & Network protocol type definitions for eBPF & Network Types \\
\hline

% Async Runtime
\multirow{2}{*}{Async Runtime} & & & \\
tokio & 1.40.0 & Asynchronous runtime for Rust & Async Framework \\
futures & 0.3.17 & Async programming utilities and combinators & Async Utilities \\
\hline

% Coordination
etcd-rs & 1.2.0 & Rust client for etcd distributed key-value store & Distributed Storage \\
\hline

% Data & Serialization
\multirow{4}{*}{Data \& Serialization} & & & \\
serde & 1.0 & Serialization framework for Rust & Data Serialization \\
serde\_json & 1.0 & JSON serialization and deserialization & JSON Processing \\
bytes & 1.0 & Efficient byte buffer operations & Buffer Management \\
once\_cell & 1.19.0 & Lazy static initialization and global state & Lazy Evaluation \\
\hline

% Time Management
chrono & 0.4.41 & Date and time library with serde support & Time Operations \\
\hline

% System Interface
libc & 0.2.159 & C library bindings for system calls & System Interface \\
\hline

% Logging
\multirow{2}{*}{Logging} & & & \\
log & 0.4.22 & Logging facade providing abstraction layer & Logging Interface \\
env\_logger & 0.11.5 & Environment-based logger implementation & Log Implementation \\
\hline

% Configuration
clap & 4.5.20 & Command-line argument parsing with derive macros & CLI Framework \\
\hline

% Error Handling
anyhow & 1.0 & Flexible error handling for applications & Error Management \\
\hline

% Build Tools
which & 6.0.0 & Cross-platform executable discovery & Build Utilities \\
\hline

% Infrastructure Tools
\multirow{8}{*}{Infrastructure \& Testing} & & & \\
Kubernetes & 1.29+ & Container orchestration platform & Orchestration \\
kubectl & 1.29+ & Kubernetes command-line interface & K8s CLI \\
kind & 0.30.0 & Kubernetes in Docker for local testing & K8s Testing \\
Docker & 27.5.1 & Container platform and runtime & Containerization \\
etcd & 3.5.9 & Distributed key-value store for coordination & Distributed Storage \\
Cilium & 1.17.6 & eBPF-based networking and security & Network CNI \\
cilium-cli & 0.18.5 & Command-line tool for Cilium management & Network Tools \\
k6 & 1.1.0 & Load testing tool for performance evaluation & Load Testing \\
\hline

\end{longtable}

\section*{Library Usage Analysis}

\subsection*{eBPF Framework Stack}
The testapp project uses the \textbf{aya} ecosystem exclusively for eBPF development, which provides a pure Rust implementation without C dependencies. The framework includes \textbf{aya-ebpf} for kernel-space program development, \textbf{aya-log} for userspace logging integration, and \textbf{aya-build} for seamless build system integration.

\subsection*{Kubernetes Integration}
Kubernetes integration is achieved through \textbf{kube-rs} (version 0.87.2) with \textbf{k8s-openapi} bindings. The project uses features including runtime support, derive macros, and unstable runtime features for advanced Kubernetes controller functionality.

\subsection*{Networking Infrastructure}
Network operations utilize \textbf{network-interface} for system network interface management and \textbf{network-types} for eBPF-compatible network protocol definitions. This combination enables both userspace network configuration and kernel-space packet processing.

\subsection*{Asynchronous Operations}
The project employs \textbf{tokio} as the primary async runtime with features for multi-threading, networking, and signal handling. \textbf{futures} provides additional combinators and utilities for complex asynchronous workflows.

\subsection*{Distributed Coordination}
Multi-node coordination is implemented using \textbf{etcd-rs} for distributed consensus and state synchronization across cluster nodes. This enables leader election and consistent state management in multi-node deployments.

\subsection*{Data Management}
Data serialization uses the \textbf{serde} framework with \textbf{serde\_json} for JSON processing and \textbf{chrono} for time-based operations. \textbf{bytes} provides efficient buffer management for network operations, while \textbf{once\_cell} enables lazy initialization of global state.

\subsection*{System Integration}
Low-level system integration is achieved through \textbf{libc} bindings for direct system calls. The \textbf{log} and \textbf{env\_logger} combination provides structured logging with environment-based configuration.

\subsection*{Development Infrastructure}
The project uses \textbf{clap} with derive macros for command-line interface development, \textbf{anyhow} for ergonomic error handling, and \textbf{which} for build-time executable discovery.

\subsection*{Infrastructure and Testing Environment}
The testing and deployment infrastructure includes \textbf{Kubernetes} (v1.29+) as the target orchestration platform, with \textbf{kubectl} for cluster management. Local development uses \textbf{kind} (Kubernetes in Docker) for isolated testing environments. \textbf{Docker} (v27.5.1) provides containerization support. \textbf{Cilium} (v1.17.6) serves as the CNI plugin with eBPF-based networking, managed via \textbf{cilium-cli}. Performance validation utilizes \textbf{k6} (v1.1.0) for load testing and benchmarking. The distributed \textbf{etcd} cluster (v3.5.9) provides coordination services for multi-node deployments.

\section*{Project Structure}

The testapp project is organized as a Rust workspace with three main crates:

\begin{itemize}
    \item \textbf{testapp}: Main application crate containing the userspace controller
    \item \textbf{testapp-common}: Shared types and utilities between userspace and eBPF
    \item \textbf{testapp-ebpf}: eBPF programs for kernel-space packet processing
\end{itemize}

This architecture ensures clean separation between kernel and userspace code while enabling shared data structures and efficient cross-boundary communication.

\section*{Dependency Rationale}

\subsection*{Minimalist Approach}
The testapp project follows a minimalist dependency approach, using only essential libraries required for core functionality. This reduces attack surface, improves build times, and simplifies maintenance.

\subsection*{Pure Rust Ecosystem}
Where possible, the project favors pure Rust implementations (such as aya for eBPF) to avoid C dependencies and leverage Rust's memory safety guarantees throughout the stack.

\subsection*{Production Readiness}
All selected libraries are mature, well-maintained, and suitable for production deployment. Version selections balance stability with access to required features.

\subsection*{Infrastructure Compatibility}
The infrastructure tools are selected for compatibility and industry standard adoption. Kubernetes provides the target deployment platform, while kind enables local development. Cilium leverages eBPF for networking, aligning with the project's eBPF focus. The tool versions are chosen to ensure compatibility across the entire stack while providing access to latest eBPF features.

\end{document} 